library angular2.transform.deferred_rewriter.transformer;

import 'dart:async';

import 'package:barback/barback.dart';

import 'package:angular2/src/transform/common/asset_reader.dart';
import 'package:angular2/src/transform/common/names.dart';
import 'package:angular2/src/transform/common/options.dart';
import 'package:angular2/src/transform/common/zone.dart' as zone;

import 'rewriter.dart';

/// Transformer responsible for rewriting deferred library loads to enable
/// initializing the reflector in a deferred way to keep the code with the
/// deferred library.
class DeferredRewriter extends AggregateTransformer implements LazyTransformer {
  final TransformerOptions options;

  DeferredRewriter(this.options);

  @override
  declareOutputs(DeclaringTransform transform) {
    transform.declareOutput(transform.primaryId);
  }

  @override
  dynamic classifyPrimary(AssetId id) {
    // Map <name>.dart and <name>.dart.deferredCount => <name>.
    // Anything else to `null`.
    var extension = null;
    if (id.path.endsWith(DEFERRED_EXTENSION)) {
      extension = DEFERRED_EXTENSION;
    } else if (id.path.endsWith('.dart') && !isGenerated(id.path)) {
      extension = '.dart';
    } else {
      return null;
    }
    return id.path.substring(0, id.path.length - extension.length);
  }

  @override
  Future apply(AggregateTransform transform) async {
    return zone.exec(() async {
      final dartAsset = await _assetToProcess(transform);
      if (dartAsset == null) return;

      var transformedCode = await rewriteDeferredLibraries(
          new AssetReader.fromTransform(transform), dartAsset.id);
      if (transformedCode != null) {
        transform
            .addOutput(new Asset.fromString(dartAsset.id, transformedCode));
      }
    }, log: transform.logger);
  }

  /// Returns the asset we need to process or `null` if none exists.
  ///
  /// Consumes the .dart.deferredCount asset if it is present.
  Future<Asset> _assetToProcess(AggregateTransform transform) async {
    // We only need to process .dart files that have an associated
    // .dart.deferredCount file with a value != "0".
    //
    // The .dart.deferredCount file is generated by a previous phase for files
    // which have deferred imports. An absent .dart.deferredCount asset is the
    // treated the same as a .dart.deferredCount asset with value "0".
    var dartAsset, deferredCountAsset;
    await for (Asset a in transform.primaryInputs) {
      if (a.id.path.endsWith(DEFERRED_EXTENSION)) {
        deferredCountAsset = a;
      } else if (a.id.path.endsWith('.dart')) {
        dartAsset = a;
      }
    }
    if (deferredCountAsset == null) return null;
    // No longer necessary.
    transform.consumePrimary(deferredCountAsset.id);
    if ((await deferredCountAsset.readAsString()) == "0") return null;
    return dartAsset;
  }
}

// Visible for testing
Future<String> rewriteDeferredLibraries(AssetReader reader, AssetId id) async {
  var rewriter = new Rewriter(id, reader);
  return await rewriter.rewrite();
}
