/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

import * as fs from 'fs';
import * as path from 'path';
import * as shx from 'shelljs';

function main(args: string[]): number {
  // Exit immediately when encountering an error.
  shx.set('-e');

  // This utility expects all of its arguments to be specified in a params file generated by
  // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
  const paramFilePath = args[0];

  // Bazel params may be surrounded with quotes
  function unquoteParameter(s: string) { return s.replace(/^'(.*)'$/, '$1'); }

  // Parameters are specified in the file one per line.
  const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);

  const [
      // Output directory for the npm package.
      out,

      // The package segment of the ng_package rule's label (e.g. 'package/common').
      srcDir,

      // The bazel-bin dir joined with the srcDir (e.g. 'bazel-bin/package.common').
      // This is the intended output location for package artifacts.
      binDir,

      // JSON data mapping each entry point to the generated bundle index and
      // flat module metadata, for example
      // {"@angular/core": {
      //     "index": "packages/core/core.js",
      //     "typing": "packages/core/core.d.ts",
      //     "metadata": "packages/core/core.metadata.json"
      //  },
      // ...
      // }
      modulesManifestArg,

      // Path to the package's README.md.
      readmeMd,

      // List of ES2015 files generated by rollup.
      esm2015Arg,

      // List of flattened, ES5 files generated by rollup.
      esm5Arg,

      // List of all UMD bundles generated by rollup.
      bundlesArg,

      // List of all files in the ng_package rule's srcs.
      srcsArg,

      // Path to the package's LICENSE.
      licenseFile,
  ] = params;

  const esm2015 = esm2015Arg.split(',').filter(s => !!s);
  const esm5 = esm5Arg.split(',').filter(s => !!s);
  const bundles = bundlesArg.split(',').filter(s => !!s);
  const srcs = srcsArg.split(',').filter(s => !!s);
  const modulesManifest = JSON.parse(modulesManifestArg);

  if (readmeMd) {
    copyFile(readmeMd, out);
  }

  /**
   * Relativize the path where the file is written.
   * @param f a path relative to the srcDir, typically from a file in the srcs[]
   * @param c content of the file
   */
  function writeSrcFile(f: string, c: string) {
    mkDirWriteFile(path.join(out, path.relative(srcDir, f)), c);
  }

  /**
   * Relativize the path where the file is written.
   * @param f a path relative to the binDir, typically from a file in the deps[]
   * @param c content of the file
   */
  function writeBinFile(f: string, c: string) {
    const outputPath = path.join(out, path.relative(binDir, f));
    mkDirWriteFile(outputPath, c);
    return outputPath;
  }

  /**
   * Copy the file, relativizing the path.
   * @param f a path relative to the binDir, typically from a file in the deps[]
   */
  function copyBinFile(f: string) { writeBinFile(f, fs.readFileSync(f, 'utf-8')); }

  /**
   * Relativize the path where a file is written.
   * @param file a path containing a re-rooted segment like .esm5 or .es6
   * @param suffix the re-rooted directory
   * @param outDir path where we copy the file, relative to the out
   */
  function writeEsmFile(file: string, suffix: string, outDir: string) {
    const root = file.substr(0, file.lastIndexOf(suffix + path.sep) + suffix.length + 1);
    const rel = path.dirname(path.relative(path.join(root, srcDir), file));
    if (!rel.startsWith('..')) {
      copyFile(file, path.join(out, outDir), rel);
    }
  }

  esm2015.forEach(file => writeEsmFile(file, '.es6', 'esm2015'));
  esm5.forEach(file => writeEsmFile(file, '.esm5', 'esm5'));

  bundles.forEach(bundle => { copyFile(bundle, out, 'bundles'); });

  const allsrcs = shx.find('-R', binDir);
  allsrcs.filter(hasFileExtension('.d.ts')).forEach((f: string) => {
    const content = fs.readFileSync(f, 'utf-8')
                        // Strip the named AMD module for compatibility with non-bazel users
                        .replace(/^\/\/\/ <amd-module name=.*\/>\n/, '');
    const outputPath = writeBinFile(f, content);
  });

  // Iterate through the entry point modules
  // We do this first because we also record new paths for the esm5 and esm2015 copies
  // of the index JS file, which we need to amend the package.json.
  Object.keys(modulesManifest).forEach(moduleName => {
    const moduleFiles = modulesManifest[moduleName];
    const indexContent = fs.readFileSync(moduleFiles['index'], 'utf-8');
    const relative = path.relative(binDir, moduleFiles['index']);

    moduleFiles['esm5_index'] = path.join(binDir, 'esm5', relative);
    moduleFiles['esm2015_index'] = path.join(binDir, 'esm2015', relative);

    writeBinFile(moduleFiles['esm5_index'], indexContent);
    writeBinFile(moduleFiles['esm2015_index'], indexContent);

    copyBinFile(moduleFiles['typings']);
    copyBinFile(moduleFiles['metadata']);
  });

  // Root package name (e.g. '@angular/common'), captures as we iterate through sources below.
  let rootPackageName = '';
  const packagesWithExistingPackageJson = new Set<string>();

  for (const src of srcs) {
    let content = fs.readFileSync(src, 'utf-8');
    // Modify package.json files as necessary for publishing
    if (path.basename(src) === 'package.json') {
      const packageJson = JSON.parse(content);
      content = amendPackageJson(src, packageJson);

      const packageName = packageJson['name'];
      packagesWithExistingPackageJson.add(packageName);

      // Keep track of the root package name, e.g. "@angular/common". We assume that the
      // root name will be shortest because secondary entry-points will append to it
      // (e.g. "@angular/common/http").
      if (!rootPackageName || packageName.length < rootPackageName.length) {
        rootPackageName = packageJson['name'];
      }
    }
    writeSrcFile(src, content);
  }

  const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf-8') : '';

  // Generate extra files for secondary entry-points.
  Object.keys(modulesManifest).forEach(entryPointPackageName => {
    const entryPointName = entryPointPackageName.substr(rootPackageName.length + 1);
    if (!entryPointName) return;

    createMetadataReexportFile(entryPointName, modulesManifest[entryPointPackageName]['metadata']);
    createTypingsReexportFile(
        entryPointName, licenseBanner, modulesManifest[entryPointPackageName]['typings']);

    if (!packagesWithExistingPackageJson.has(entryPointPackageName)) {
      createEntryPointPackageJson(entryPointName, entryPointPackageName);
    }
  });

  return 0;

  /**
   * Convert a binDir-relative path to srcDir-relative
   * @param from path to a file under the srcDir, like packages/core/testing/package.json
   * @param file path to a file under the binDir, like bazel-bin/core/testing/generated.js
   */
  function srcDirRelative(from: string, file: string) {
    const result =
        path.relative(path.dirname(from), path.join(srcDir, path.relative(binDir, file)));
    if (result.startsWith('..')) return result;
    return `./${result}`;
  }

  /** Gets a predicate function to filter non-generated files with a specified extension. */
  function hasFileExtension(ext: string): (path: string) => boolean {
    return f => f.endsWith(ext) && !f.endsWith(`.ngfactory${ext}`) &&
        !f.endsWith(`.ngsummary${ext}`);
  }

  function mkDirWriteFile(p: string, content: string) {
    shx.mkdir('-p', path.dirname(p));
    fs.writeFileSync(p, content, 'utf-8');
  }

  function copyFile(file: string, baseDir: string, relative = '.') {
    const dir = path.join(baseDir, relative);
    shx.mkdir('-p', dir);
    shx.cp(file, dir);
  }

  function copyFesm(file: string, baseDir: string) {
    const parts = path.basename(file).split('__');
    const entryPointName = parts.join('/').replace(/\..*/, '');
    const filename = parts.splice(-1)[0];
    const dir = path.join(baseDir, ...parts);
    shx.mkdir('-p', dir);
    shx.cp(file, dir);
    shx.mv(path.join(dir, path.basename(file)), path.join(dir, filename));
  }

  /**
   * Inserts or edits properties into the package.json file(s) in the package so that
   * they point to all the right generated artifacts.
   *
   * @param parsedPackage Parsed package.json content
   */
  function amendPackageJson(packageJson: string, parsedPackage: {[key: string]: string}) {
    const packageName = parsedPackage['name'];
    const moduleFiles = modulesManifest[packageName];
    if (!moduleFiles) {
      // Ideally we should throw here, as we got an entry point that doesn't
      // have flat module metadata / bundle index, so it may have been an
      // ng_module that's missing a module_name attribute.
      // However, @angular/compiler can't be an ng_module, as it's the internals
      // of the ngc compiler, yet we want to build an ng_package for it.
      // So ignore package.json files when we are missing data.
      console.error('WARNING: no module metadata for package', packageName);
      console.error('   Not updating the package.json file to point to it');
      return JSON.stringify(parsedPackage, null, 2);
    }

    parsedPackage['main'] = getUmdBundleName(packageName);
    parsedPackage['module'] = parsedPackage['esm5'] =
        srcDirRelative(packageJson, moduleFiles['esm5_index']);
    parsedPackage['es2015'] = parsedPackage['esm2015'] =
        srcDirRelative(packageJson, moduleFiles['esm2015_index']);
    parsedPackage['typings'] = srcDirRelative(packageJson, moduleFiles['typings']);
    return JSON.stringify(parsedPackage, null, 2);
  }

  // e.g. @angular/common/http/testing -> ../../bundles/common-http-testing.umd.js
  function getUmdBundleName(packageName: string) {
    const parts = packageName.split('/');
    // Remove the scoped package part, like @angular if present
    const nameParts = packageName.startsWith('@') ? parts.splice(1) : parts;
    const relativePath = Array(nameParts.length - 1).fill('..').join('/') || '.';
    return `${relativePath}/bundles/${nameParts.join('-')}.umd.js`;
  }

  /** Creates metadata re-export file for a secondary entry-point. */
  function createMetadataReexportFile(entryPointName: string, metadataFile: string) {
    const inputPath = path.join(srcDir, `${entryPointName}.metadata.json`);
    writeSrcFile(inputPath, JSON.stringify({
      '__symbolic': 'module',
      'version': 3,
      'metadata': {},
      'exports':
          [{'from': `${srcDirRelative(inputPath, metadataFile.replace(/.metadata.json$/, ''))}`}],
      'flatModuleIndexRedirect': true
    }) + '\n');
  }

  /**
   * Creates a typings (d.ts) re-export file for a secondary-entry point,
   * e.g., `export * from './common/common'`
   */
  function createTypingsReexportFile(entryPointName: string, license: string, typingsFile: string) {
    const inputPath = path.join(srcDir, `${entryPointName}.d.ts`);
    const content = `${license}
  export * from '${srcDirRelative(inputPath, typingsFile.replace(/\.d\.tsx?$/, ''))}';
  `;
    writeSrcFile(inputPath, content);
  }

  /**
   * Creates a package.json for a secondary entry-point.
   * @param entryPointPackageName The full package name for the entry point,
   *     e.g. '@angular/common/http'.
   */
  function createEntryPointPackageJson(dir: string, entryPointPackageName: string) {
    const pkgJson = path.join(srcDir, dir, 'package.json');
    const content = amendPackageJson(pkgJson, {name: entryPointPackageName});
    writeSrcFile(pkgJson, content);
  }
}

if (require.main === module) {
  process.exitCode = main(process.argv.slice(2));
}
